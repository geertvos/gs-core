package net.geertvos.gvm.core;

import java.util.Map;
import java.util.Stack;

import net.geertvos.gvm.core.Value.TYPE;
import net.geertvos.gvm.program.GVMFunction;
import net.geertvos.gvm.program.GVMProgram;
import net.geertvos.gvm.streams.RandomAccessByteStream;

public class GVMThread {

	//The stack for the virtual machine, holds local variables and intermediate results
	private final Stack<Value> stack = new Stack<Value>();

	//The start location on the stack of the current frame
	private int framepointer;
	
	//The current identifier of the function
	private int functionPointer;

	//The current line number
	private int debugLineNumber = -1;

	//Stack frames
	private final Stack<StackFrame> callStack = new Stack<>();
	
	//Bytecode of the current function
	private RandomAccessByteStream bytecode;
	
	//Current program
	private GVMProgram program;

	private int location;

	private Map<Integer, GVMObject> heap;

	public GVMThread(GVMProgram program, Map<Integer, GVMObject> heap) {
		framepointer = 0;
		functionPointer = 0;
		debugLineNumber = -1;
		this.heap = heap;
		this.program = program;
	}
	
	public int getFramepointer() {
		return framepointer;
	}

	public void setFramepointer(int framepointer) {
		this.framepointer = framepointer;
	}

	public int getFunctionPointer() {
		return functionPointer;
	}

	public void setFunctionPointer(int functionPointer) {
		this.functionPointer = functionPointer;
	}

	public int getDebugLineNumber() {
		return debugLineNumber;
	}

	public void setDebugLineNumber(int debugLineNumber) {
		this.debugLineNumber = debugLineNumber;
	}

	public RandomAccessByteStream getBytecode() {
		return bytecode;
	}

	public void setBytecode(RandomAccessByteStream bytecode) {
		this.bytecode = bytecode;
	}

	public GVMProgram getProgram() {
		return program;
	}

	public void setProgram(GVMProgram program) {
		this.program = program;
	}

	public int getLocation() {
		return location;
	}

	public void setLocation(int location) {
		this.location = location;
	}

	public Stack<Value> getStack() {
		return stack;
	}

	public Stack<StackFrame> getCallStack() {
		return callStack;
	}
	
	private boolean peel()
	{
		//Do not peel the values pushed by the VM itself
		if( callStack.size() == 1 )
			return false;
		
		//Remove local variables and parameters
		while( callStack.size() > getFramepointer() )
			callStack.pop();
		
		StackFrame frame =  callStack.pop();
		setDebugLineNumber(frame.getLineNumber());
		setFunctionPointer(frame.getCallingFunction()); //Function pointer
		setFramepointer(frame.getFramePointer());
		setLocation(frame.getLocation());
		int pc = frame.getProgramCounter(); //PC
		setBytecode(program.getFunction(getFunctionPointer()).getBytecode());
		getBytecode().seek(pc);
		return true;
	}
	
	void handleException(String message)
	{
		int index = program.addString(message);
		Value exceptionMessage = new Value(index,Value.TYPE.STRING);
		
		GVMObject exceptionObject = new GVMPlainObject();
		exceptionObject.setValue("message", exceptionMessage);
		exceptionObject.setValue("line", new Value(getDebugLineNumber(), Value.TYPE.NUMBER));
		exceptionObject.setValue("location", new Value(getLocation(), Value.TYPE.STRING));
		int id = heap.size()+1;
		heap.put(id, exceptionObject);
		handleExceptionObject(new Value(id,Value.TYPE.OBJECT));
	}
	
	/**
	 * Handle the exception in the current function. When this function has no exception handler attached, the function
	 * is peeled from the stack and the underlying function is checked.
	 * @param message The error message generated by the VM
	 */
	void handleExceptionObject(Value exception)
	{
		//Locate the catch block (if there is one)
		GVMFunction f = program.getFunction(getFunctionPointer());
		int catchBlock = f.getExceptionHandler(getBytecode().getPointerPosition());
		if( catchBlock > -1 )
		{
			//Catch block located, push error message on the stack
			getStack().push(exception);
			//And relocate the program counter
			getBytecode().seek(catchBlock);
		} else {
			//No catch block found, see if we can peel off the current function from the stack
			if( peel() )
			{
				//We peeled one off, recursively handle the exception.
				handleExceptionObject(exception);
			} else {
				String message = "Unhandled unknown exception";
				if(exception.getType() == TYPE.OBJECT) {
					GVMObject exceptionObj = heap.get(exception.getValue());
					String exceptionMsg = program.getString(exceptionObj.getValue("message").getValue());
					int exceptionLine = exceptionObj.getValue("line").getValue();
					message = String.format("Unhandled exception '%s' at line %d", exceptionMsg, exceptionLine); 
				}
				System.err.println(message);
				System.exit(1);
			}
		}
	}

	
}
