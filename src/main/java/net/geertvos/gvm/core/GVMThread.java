package net.geertvos.gvm.core;

import java.util.Stack;
import java.util.concurrent.CountDownLatch;

import net.geertvos.gvm.core.Type.Operations;
import net.geertvos.gvm.program.GVMContext;
import net.geertvos.gvm.program.GVMFunction;
import net.geertvos.gvm.program.GVMHeap;
import net.geertvos.gvm.program.GVMProgram;
import net.geertvos.gvm.streams.RandomAccessByteStream;

public class GVMThread {

	private final GVMProgram program;
	private final GVMHeap heap;

	private int framepointer;
	private int functionPointer;
	private int debugLineNumber = -1;
	private final Stack<StackFrame> callStack;
	private final Stack<Value> stack;
	private RandomAccessByteStream executingBytecode;

	private int location; //reference to the name of this module/file/source

	private CountDownLatch threadFinishedLatch = new CountDownLatch(1); 
	
	public GVMThread(GVMProgram program, GVMHeap heap) {
		this.framepointer = 0;
		this.functionPointer = 0;
		this.debugLineNumber = -1;
		this.heap = heap;
		this.program = program;
		this.callStack = new Stack<>();
		this.stack = new Stack<Value>();
	}
	
	private GVMThread(GVMProgram program, GVMHeap heap, Stack<StackFrame> callStack, Stack<Value> stack) {
		this.framepointer = 0;
		this.functionPointer = 0;
		this.debugLineNumber = -1;
		this.heap = heap;
		this.program = program;
		this.stack = stack;
		this.callStack = callStack;
	}
	
	public int getFramepointer() {
		return framepointer;
	}

	public void setFramepointer(int framepointer) {
		this.framepointer = framepointer;
	}

	public int getFunctionPointer() {
		return functionPointer;
	}

	public void setFunctionPointer(int functionPointer) {
		this.functionPointer = functionPointer;
	}

	public int getDebugLineNumber() {
		return debugLineNumber;
	}

	public void setDebugLineNumber(int debugLineNumber) {
		this.debugLineNumber = debugLineNumber;
	}

	public RandomAccessByteStream getBytecode() {
		return executingBytecode;
	}

	public void setBytecode(RandomAccessByteStream bytecode) {
		this.executingBytecode = bytecode;
	}

	public GVMProgram getProgram() {
		return program;
	}

	public int getLocation() {
		return location;
	}

	public void setLocation(int location) {
		this.location = location;
	}

	public Stack<Value> getStack() {
		return stack;
	}

	public Stack<StackFrame> getCallStack() {
		return callStack;
	}
	
	private boolean peel()
	{
		//Do not peel the values pushed by the VM itself
		if( callStack.size() == 1 )
			return false;
		
		//Remove local variables and parameters
		while( callStack.size() > getFramepointer() )
			callStack.pop();
		
		StackFrame frame =  callStack.pop();
		setDebugLineNumber(frame.getLineNumber());
		setFunctionPointer(frame.getCallingFunction()); //Function pointer
		setFramepointer(frame.getFramePointer());
		setLocation(frame.getLocation());
		int pc = frame.getProgramCounter(); //PC
		setBytecode(program.getFunction(getFunctionPointer()).getBytecode().clone());
		getBytecode().seek(pc);
		return true;
	}
	
	void markThreadFinished() {
		threadFinishedLatch.countDown();
	}
	
	void awaitFinished() {
		try {
			threadFinishedLatch.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	void handleException(String message)
	{
		GVMContext context = new GVMContext(program, heap, this);
		Value value = program.getExceptionHandler().convert(message, context, getDebugLineNumber(), getLocation());
		handleExceptionObject(value);
	}
	
	/**
	 * Handle the exception in the current function. When this function has no exception handler attached, the function
	 * is peeled from the stack and the underlying function is checked.
	 * @param message The error message generated by the VM
	 */
	void handleExceptionObject(Value exception)
	{
		//Locate the catch block (if there is one)
		GVMFunction f = program.getFunction(getFunctionPointer());
		int catchBlock = f.getExceptionHandler(getBytecode().getPointerPosition());
		if( catchBlock > -1 )
		{
			//Catch block located, push error message on the stack
			getStack().push(exception);
			//And relocate the program counter
			getBytecode().seek(catchBlock);
		} else {
			//No catch block found, see if we can peel off the current function from the stack
			if( peel() )
			{
				//We peeled one off, recursively handle the exception.
				handleExceptionObject(exception);
			} else {
				String message = "Unhandled unknown exception";
				if(exception.getType().supportsOperation(Operations.GET)) {
					GVMObject exceptionObj = heap.getObject(exception.getValue());
					//TODO: THis will become language dependent
					String exceptionMsg = program.getString(exceptionObj.getValue("message").getValue());
					int exceptionLine = exceptionObj.getValue("line").getValue();
					message = String.format("Unhandled exception '%s' at line %d", exceptionMsg, exceptionLine); 
				}
				System.err.println(message);
				System.exit(1);
			}
		}
	}

	public GVMThread fork() {
		Stack<StackFrame> newCallStack = (Stack<StackFrame>) getCallStack().clone(); 

		StackFrame toclone = newCallStack.pop();
		Value v = toclone.getScope();
		GVMObject object = heap.getObject(v.getValue());
		GVMObject clonedScope = object.clone();
		int ref = heap.addObject(clonedScope);
		Value newScope = new Value(ref, v.getType());
		newCallStack.add(new StackFrame(toclone.getProgramCounter(), toclone.getFramePointer(), toclone.getCallingFunction(), toclone.getLineNumber(), toclone.getLocation(), newScope));

		Stack<Value> newStack = (Stack<Value>) getStack().clone();
		GVMThread thread = new GVMThread(program, heap, newCallStack, newStack);
		thread.setBytecode(this.executingBytecode.clone());
		thread.executingBytecode.seek(this.executingBytecode.getPointerPosition());
		thread.setDebugLineNumber(debugLineNumber);
		thread.setFramepointer(framepointer);
		thread.setFunctionPointer(functionPointer);
		thread.setLocation(location);
		this.stack.push(new Value(0, new BooleanType(), "Fork return value"));
		thread.stack.push(new Value(1, new BooleanType(), "Fork return value"));
		return thread;
	}

	
}
